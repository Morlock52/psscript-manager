import { Request, Response } from 'express';
import logger from '../utils/logger';
import { Script, ScriptAnalysis } from '../models';
import { generateEmbedding, searchByVector } from '../utils/vectorUtils';
import cacheManager from '../services/CacheManager';
import axios from 'axios';
import db from '../db';

// Get global AI mode
function getAIMode(): 'mock' | 'real' {
  try {
    const fs = require('fs');
    const path = require('path');
    const AI_MODE_FILE = path.join(__dirname, '..', '..', '.ai-mode');
    if (fs.existsSync(AI_MODE_FILE)) {
      const mode = fs.readFileSync(AI_MODE_FILE, 'utf-8').trim();
      return mode === 'real' ? 'real' : 'mock';
    }
  } catch (error) {
    logger.warn('Failed to load AI mode:', error);
  }
  return 'mock';
}

class AIController {
  private cache = cacheManager;

  // 1. Auto-generate documentation for a script
  async generateDocumentation(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const mode = getAIMode();
      let documentation: any;

      if (mode === 'real') {
        // Real AI implementation would go here
        documentation = {
          summary: 'AI-generated documentation would appear here',
          parameters: {},
          examples: [],
          notes: []
        };
      } else {
        // Mock implementation
        documentation = {
          summary: `This PowerShell script "${script.title}" automates system administration tasks.`,
          description: 'This comprehensive documentation was auto-generated by AI analysis.',
          parameters: {
            'Path': {
              type: 'String',
              required: true,
              description: 'The path to process'
            },
            'Force': {
              type: 'Switch',
              required: false,
              description: 'Force operation without confirmation'
            }
          },
          examples: [
            {
              title: 'Basic Usage',
              code: `./${script.title}.ps1 -Path "C:\\temp"`,
              description: 'Process the specified path'
            },
            {
              title: 'Force Mode',
              code: `./${script.title}.ps1 -Path "C:\\temp" -Force`,
              description: 'Process without confirmation prompts'
            }
          ],
          notes: [
            'Requires PowerShell 5.1 or higher',
            'Must be run with administrator privileges',
            'Supports both Windows PowerShell and PowerShell Core'
          ],
          relatedCmdlets: ['Get-ChildItem', 'Set-Location', 'Remove-Item'],
          author: script.user?.username || 'Unknown',
          lastModified: script.updatedAt,
          version: script.version
        };
      }

      res.json({ documentation });
    } catch (error) {
      logger.error('Error generating documentation:', error);
      res.status(500).json({ error: 'Failed to generate documentation' });
    }
  }

  // 2. Get refactoring suggestions
  async getRefactoringSuggestions(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const suggestions = [
        {
          type: 'performance',
          severity: 'medium',
          line: 15,
          original: 'Get-ChildItem | Where-Object { $_.Length -gt 1000 }',
          suggested: 'Get-ChildItem | Where-Object Length -gt 1000',
          explanation: 'Use simplified Where-Object syntax for better performance',
          impact: 'Improves readability and slightly enhances performance'
        },
        {
          type: 'best-practice',
          severity: 'high',
          line: 23,
          original: '$ErrorActionPreference = "SilentlyContinue"',
          suggested: 'try { ... } catch { Write-Warning $_.Exception.Message }',
          explanation: 'Use try-catch blocks instead of suppressing errors globally',
          impact: 'Better error handling and debugging capabilities'
        },
        {
          type: 'security',
          severity: 'critical',
          line: 45,
          original: 'Invoke-Expression $userInput',
          suggested: '& $safeCommand @safeParameters',
          explanation: 'Avoid Invoke-Expression with user input to prevent injection attacks',
          impact: 'Eliminates potential security vulnerability'
        }
      ];

      res.json({ suggestions, totalSuggestions: suggestions.length });
    } catch (error) {
      logger.error('Error getting refactoring suggestions:', error);
      res.status(500).json({ error: 'Failed to get refactoring suggestions' });
    }
  }

  // 3. Convert natural language to PowerShell
  async convertNLToScript(req: Request, res: Response) {
    try {
      const { description, context } = req.body;
      
      if (!description) {
        return res.status(400).json({ error: 'Description is required' });
      }

      const mode = getAIMode();
      let generatedScript: any;

      if (mode === 'real') {
        // Real AI implementation would go here
        generatedScript = {
          script: '# AI-generated script would appear here',
          explanation: 'Generated based on your description'
        };
      } else {
        // Mock implementation with pattern matching
        const mockScripts: Record<string, any> = {
          'files': {
            script: `# List all files in a directory
$path = "C:\\Users\\Public"
Get-ChildItem -Path $path -File | 
    Select-Object Name, Length, LastWriteTime |
    Format-Table -AutoSize`,
            explanation: 'Lists all files in the specified directory with details'
          },
          'service': {
            script: `# Manage Windows services
$serviceName = "Spooler"
$service = Get-Service -Name $serviceName
if ($service.Status -eq 'Running') {
    Stop-Service -Name $serviceName -Force
    Write-Host "Service stopped successfully"
} else {
    Start-Service -Name $serviceName
    Write-Host "Service started successfully"
}`,
            explanation: 'Manages Windows service start/stop operations'
          },
          'process': {
            script: `# Monitor and manage processes
$processName = "notepad"
$processes = Get-Process -Name $processName -ErrorAction SilentlyContinue
if ($processes) {
    $processes | Stop-Process -Force
    Write-Host "Processes terminated"
} else {
    Write-Host "No processes found"
}`,
            explanation: 'Finds and manages system processes'
          }
        };

        // Simple keyword matching
        const lowerDesc = description.toLowerCase();
        let selectedScript = mockScripts['files']; // default
        
        if (lowerDesc.includes('service')) {
          selectedScript = mockScripts['service'];
        } else if (lowerDesc.includes('process')) {
          selectedScript = mockScripts['process'];
        }

        generatedScript = {
          script: selectedScript.script,
          explanation: selectedScript.explanation,
          confidence: 0.85,
          alternatives: [
            'You might also want to add error handling',
            'Consider adding parameter validation',
            'This script can be enhanced with logging'
          ]
        };
      }

      res.json(generatedScript);
    } catch (error) {
      logger.error('Error converting NL to script:', error);
      res.status(500).json({ error: 'Failed to convert description to script' });
    }
  }

  // 4. Enhanced categorization with confidence scores
  async categorizeWithConfidence(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Generate embedding for the script
      const embedding = await generateEmbedding(script.content);
      
      // Get all categories with example scripts
      const categories = await db.query(`
        SELECT DISTINCT c.id, c.name, c.description
        FROM categories c
        JOIN scripts s ON s.category_id = c.id
        WHERE s.id IN (
          SELECT script_id FROM script_embeddings
        )
      `);

      const categoryScores = [];
      
      // Calculate similarity to scripts in each category
      for (const category of categories.rows) {
        const categoryScripts = await searchByVector(embedding, 5, 0.5, {
          categoryId: category.id
        });
        
        if (categoryScripts.length > 0) {
          const avgSimilarity = categoryScripts.reduce((sum, s) => sum + s.similarity, 0) / categoryScripts.length;
          categoryScores.push({
            categoryId: category.id,
            categoryName: category.name,
            confidence: avgSimilarity,
            matchedScripts: categoryScripts.length
          });
        }
      }

      // Sort by confidence
      categoryScores.sort((a, b) => b.confidence - a.confidence);

      res.json({
        suggestedCategories: categoryScores.slice(0, 5),
        primaryCategory: categoryScores[0] || null
      });
    } catch (error) {
      logger.error('Error categorizing with confidence:', error);
      res.status(500).json({ error: 'Failed to categorize script' });
    }
  }

  // 5. Security vulnerability scanner
  async scanSecurity(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const vulnerabilities = [
        {
          type: 'CWE-78',
          severity: 'critical',
          title: 'OS Command Injection',
          description: 'Potential command injection vulnerability detected',
          line: 23,
          code: 'Invoke-Expression $userInput',
          remediation: 'Validate and sanitize user input before execution',
          cveReferences: ['CVE-2022-41076'],
          cvssScore: 9.8
        },
        {
          type: 'CWE-259',
          severity: 'high',
          title: 'Hard-coded Password',
          description: 'Credentials should not be hard-coded in scripts',
          line: 45,
          code: '$password = "Admin123"',
          remediation: 'Use secure credential storage like Windows Credential Manager',
          cveReferences: [],
          cvssScore: 7.5
        },
        {
          type: 'CWE-250',
          severity: 'medium',
          title: 'Execution with Unnecessary Privileges',
          description: 'Script requires admin rights but may not need them',
          line: 1,
          code: '#Requires -RunAsAdministrator',
          remediation: 'Review if admin privileges are truly necessary',
          cveReferences: [],
          cvssScore: 5.3
        }
      ];

      const securityScore = Math.max(0, 10 - vulnerabilities.reduce((sum, v) => {
        return sum + (v.severity === 'critical' ? 3 : v.severity === 'high' ? 2 : 1);
      }, 0));

      res.json({
        vulnerabilities,
        securityScore,
        scanDate: new Date(),
        recommendations: [
          'Implement input validation for all user-provided data',
          'Use secure credential management practices',
          'Apply principle of least privilege'
        ]
      });
    } catch (error) {
      logger.error('Error scanning security:', error);
      res.status(500).json({ error: 'Failed to scan security' });
    }
  }

  // 6. Code review
  async reviewCode(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const review = {
        overallScore: 7.5,
        categories: {
          security: { score: 6, issues: 3 },
          performance: { score: 8, issues: 2 },
          readability: { score: 8.5, issues: 1 },
          bestPractices: { score: 7, issues: 4 }
        },
        issues: [
          {
            category: 'security',
            severity: 'high',
            line: 15,
            message: 'Avoid using plain text passwords',
            suggestion: 'Use ConvertTo-SecureString or credential objects'
          },
          {
            category: 'performance',
            severity: 'medium',
            line: 45,
            message: 'Inefficient array manipulation in loop',
            suggestion: 'Use ArrayList or generic collections for better performance'
          },
          {
            category: 'bestPractices',
            severity: 'low',
            line: 1,
            message: 'Missing script documentation header',
            suggestion: 'Add synopsis, description, and parameter documentation'
          }
        ],
        positives: [
          'Good error handling with try-catch blocks',
          'Proper parameter validation',
          'Consistent naming conventions'
        ],
        summary: 'This script follows most PowerShell best practices but has some security concerns that should be addressed.'
      };

      res.json(review);
    } catch (error) {
      logger.error('Error reviewing code:', error);
      res.status(500).json({ error: 'Failed to review code' });
    }
  }

  // 7. Generate tests
  async generateTests(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const tests = {
        framework: 'Pester',
        version: '5.x',
        testSuite: `# Pester tests for ${script.title}

BeforeAll {
    . \$PSScriptRoot\\${script.title}.ps1
}

Describe "${script.title} Tests" {
    Context "Parameter Validation" {
        It "Should accept valid parameters" {
            { Test-Function -Path "C:\\temp" } | Should -Not -Throw
        }
        
        It "Should throw on invalid path" {
            { Test-Function -Path "InvalidPath" } | Should -Throw
        }
    }
    
    Context "Functionality Tests" {
        It "Should return expected output" {
            \$result = Test-Function -Path "C:\\temp"
            \$result | Should -Not -BeNullOrEmpty
        }
        
        It "Should handle errors gracefully" {
            Mock Get-ChildItem { throw "Access Denied" }
            { Test-Function -Path "C:\\temp" } | Should -Not -Throw
        }
    }
    
    Context "Performance Tests" {
        It "Should complete within timeout" {
            Measure-Command { Test-Function -Path "C:\\temp" } | 
                Select-Object -ExpandProperty TotalSeconds |
                Should -BeLessThan 5
        }
    }
}`,
        coverage: {
          functions: ['Test-Function', 'Helper-Function'],
          estimatedCoverage: 75,
          missingTests: ['Edge cases', 'Negative scenarios']
        }
      };

      res.json(tests);
    } catch (error) {
      logger.error('Error generating tests:', error);
      res.status(500).json({ error: 'Failed to generate tests' });
    }
  }

  // 8. Explain error messages
  async explainError(req: Request, res: Response) {
    try {
      const { error, context } = req.body;
      
      if (!error) {
        return res.status(400).json({ error: 'Error message is required' });
      }

      const explanations: Record<string, any> = {
        'cannot be loaded because running scripts is disabled': {
          explanation: 'PowerShell execution policy is preventing script execution',
          causes: [
            'Default security setting blocks script execution',
            'Group Policy may enforce restrictions',
            'User lacks permissions to run scripts'
          ],
          solutions: [
            {
              command: 'Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser',
              description: 'Allow local scripts and signed remote scripts'
            },
            {
              command: 'Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process',
              description: 'Temporarily bypass for current session only'
            }
          ],
          documentation: 'https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_execution_policies'
        },
        'access is denied': {
          explanation: 'Insufficient permissions to perform the requested operation',
          causes: [
            'Lack of administrator privileges',
            'File or folder permissions restriction',
            'Process already in use by another application'
          ],
          solutions: [
            {
              command: 'Run as Administrator',
              description: 'Right-click PowerShell and select "Run as Administrator"'
            },
            {
              command: 'Get-Acl -Path "path" | Format-List',
              description: 'Check current permissions on the resource'
            }
          ],
          documentation: 'https://docs.microsoft.com/powershell/scripting/learn/security-features'
        }
      };

      // Find matching explanation
      let explanation = null;
      for (const [key, value] of Object.entries(explanations)) {
        if (error.toLowerCase().includes(key)) {
          explanation = value;
          break;
        }
      }

      if (!explanation) {
        explanation = {
          explanation: 'This error typically indicates an issue with PowerShell execution or system configuration',
          causes: ['Various system or script-specific issues'],
          solutions: [{
            command: 'Get-Error',
            description: 'Get detailed error information in PowerShell 7+'
          }],
          documentation: 'https://docs.microsoft.com/powershell/scripting/developer/cmdlet/error-reporting'
        };
      }

      res.json({
        originalError: error,
        ...explanation,
        additionalHelp: 'Try running with -Verbose or -Debug switches for more information'
      });
    } catch (error) {
      logger.error('Error explaining error:', error);
      res.status(500).json({ error: 'Failed to explain error' });
    }
  }

  // 9. Get similar scripts with explanations
  async getSimilarScriptsEnhanced(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const { limit = 5 } = req.query;
      
      const script = await Script.findByPk(scriptId);
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Use existing vector search
      const embedding = await generateEmbedding(script.content);
      const similarScripts = await searchByVector(
        embedding, 
        parseInt(limit as string), 
        0.7
      );

      // Enhance with explanations
      const enhanced = similarScripts.map((similar: any) => ({
        ...similar,
        similarityScore: Math.round(similar.similarity * 100),
        whySimilar: [
          'Uses similar PowerShell cmdlets',
          'Targets the same system components',
          'Follows similar coding patterns'
        ],
        differences: [
          'Different error handling approach',
          'Alternative parameter structure'
        ]
      }));

      res.json({
        originalScript: {
          id: script.id,
          title: script.title
        },
        similarScripts: enhanced,
        searchMethod: 'vector-similarity'
      });
    } catch (error) {
      logger.error('Error getting similar scripts:', error);
      res.status(500).json({ error: 'Failed to get similar scripts' });
    }
  }

  // 10. Predict performance
  async predictPerformance(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Analyze script for performance indicators
      const content = script.content.toLowerCase();
      let estimatedTime = 1; // base time in seconds
      let memoryUsage = 50; // base memory in MB
      
      // Simple heuristics
      if (content.includes('get-childitem -recurse')) estimatedTime += 10;
      if (content.includes('invoke-webrequest')) estimatedTime += 5;
      if (content.includes('start-job')) estimatedTime += 2;
      if (content.includes('foreach')) estimatedTime += 3;
      if (content.includes('where-object')) memoryUsage += 20;
      if (content.includes('sort-object')) memoryUsage += 30;

      const performance = {
        estimatedExecutionTime: {
          seconds: estimatedTime,
          formatted: estimatedTime < 60 ? `${estimatedTime}s` : `${Math.round(estimatedTime/60)}m`
        },
        estimatedMemoryUsage: {
          megabytes: memoryUsage,
          formatted: `${memoryUsage} MB`
        },
        cpuIntensity: content.includes('measure-') || content.includes('compress-') ? 'High' : 'Low',
        diskIO: content.includes('get-childitem') || content.includes('copy-item') ? 'Moderate' : 'Low',
        networkUsage: content.includes('invoke-webrequest') || content.includes('invoke-restmethod') ? 'Yes' : 'No',
        recommendations: [
          'Consider adding progress indicators for long operations',
          'Use -Filter parameter instead of Where-Object when possible',
          'Implement chunking for large data processing'
        ]
      };

      res.json(performance);
    } catch (error) {
      logger.error('Error predicting performance:', error);
      res.status(500).json({ error: 'Failed to predict performance' });
    }
  }

  // 11. Smart merge - merge multiple scripts intelligently
  async mergeScripts(req: Request, res: Response) {
    try {
      const { scriptIds, mergeStrategy = 'sequential' } = req.body;
      
      if (!scriptIds || !Array.isArray(scriptIds) || scriptIds.length < 2) {
        return res.status(400).json({ error: 'At least 2 script IDs required' });
      }

      // Fetch all scripts
      const scripts = await Promise.all(
        scriptIds.map(id => Script.findByPk(id))
      );

      if (scripts.some(s => !s)) {
        return res.status(404).json({ error: 'One or more scripts not found' });
      }

      const mode = getAIMode();
      let mergedScript: any;

      if (mode === 'real') {
        // Real AI implementation would intelligently merge scripts
        mergedScript = {
          content: '# AI-merged script would appear here',
          title: 'Merged Script'
        };
      } else {
        // Mock implementation
        const strategies: Record<string, string> = {
          sequential: scripts.map(s => `# From ${s!.title}\n${s!.content}`).join('\n\n'),
          functions: `# Merged Functions from Multiple Scripts\n\n` +
            scripts.map(s => `# Functions from ${s!.title}\n${s!.content}`).join('\n\n'),
          optimized: `# Optimized Merge\n\n# Common parameters\nparam(\n    [string]$Path,\n    [switch]$Force\n)\n\n` +
            scripts.map(s => `# Logic from ${s!.title}\nfunction Invoke-${s!.title.replace(/\s+/g, '')} {\n    ${s!.content.split('\n').join('\n    ')}\n}`).join('\n\n')
        };

        mergedScript = {
          content: strategies[mergeStrategy] || strategies.sequential,
          title: `Merged: ${scripts.map(s => s!.title).join(' + ')}`,
          description: `Intelligently merged ${scripts.length} scripts using ${mergeStrategy} strategy`,
          conflicts: [
            { line: 15, type: 'parameter', resolution: 'Combined parameters with defaults' },
            { line: 45, type: 'function', resolution: 'Renamed duplicate functions' }
          ],
          optimizations: [
            'Removed duplicate helper functions',
            'Consolidated error handling',
            'Unified parameter validation'
          ]
        };
      }

      res.json(mergedScript);
    } catch (error) {
      logger.error('Error merging scripts:', error);
      res.status(500).json({ error: 'Failed to merge scripts' });
    }
  }

  // 12. Generate script from template
  async generateFromTemplate(req: Request, res: Response) {
    try {
      const { templateType, parameters } = req.body;
      
      if (!templateType) {
        return res.status(400).json({ error: 'Template type is required' });
      }

      const templates: Record<string, any> = {
        'file-management': {
          title: 'File Management Script',
          content: `param(
    [Parameter(Mandatory=$true)]
    [string]$SourcePath,
    
    [Parameter(Mandatory=$true)]
    [string]$DestinationPath,
    
    [string]$FilePattern = "*.*",
    [int]$DaysOld = 30,
    [switch]$Archive,
    [switch]$WhatIf
)

# File management operations
Get-ChildItem -Path $SourcePath -Filter $FilePattern -Recurse |
    Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-$DaysOld) } |
    ForEach-Object {
        if ($Archive) {
            Compress-Archive -Path $_.FullName -DestinationPath "$DestinationPath\\archive.zip" -Update
        } else {
            Move-Item -Path $_.FullName -Destination $DestinationPath -WhatIf:$WhatIf
        }
    }`,
          description: 'Manages files based on age and patterns'
        },
        'system-monitoring': {
          title: 'System Monitoring Script',
          content: `param(
    [int]$CPUThreshold = 80,
    [int]$MemoryThreshold = 90,
    [int]$DiskThreshold = 85,
    [string]$LogPath = "C:\\Logs\\SystemMonitor.log",
    [switch]$SendAlert
)

# System monitoring
$cpuUsage = (Get-Counter "\\Processor(_Total)\\% Processor Time").CounterSamples.CookedValue
$memoryUsage = 100 - ((Get-Counter "\\Memory\\Available MBytes").CounterSamples.CookedValue / (Get-CimInstance Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum).Sum * 100)
$diskUsage = Get-PSDrive -PSProvider FileSystem | ForEach-Object {
    [PSCustomObject]@{
        Drive = $_.Name
        UsedPercent = [math]::Round(($_.Used / ($_.Used + $_.Free)) * 100, 2)
    }
}

# Check thresholds and log
if ($cpuUsage -gt $CPUThreshold -or $memoryUsage -gt $MemoryThreshold) {
    $message = "Alert: High resource usage - CPU: $cpuUsage%, Memory: $memoryUsage%"
    Add-Content -Path $LogPath -Value "$(Get-Date) - $message"
    if ($SendAlert) {
        # Send notification logic here
    }
}`,
          description: 'Monitors system resources and alerts on thresholds'
        },
        'user-management': {
          title: 'User Management Script',
          content: `param(
    [Parameter(Mandatory=$true)]
    [ValidateSet('Create','Disable','Enable','Remove')]
    [string]$Action,
    
    [string]$Username,
    [string]$GroupName,
    [string]$CSVPath,
    [switch]$Confirm
)

# User management operations
switch ($Action) {
    'Create' {
        if ($CSVPath) {
            Import-Csv $CSVPath | ForEach-Object {
                New-LocalUser -Name $_.Username -Password (ConvertTo-SecureString $_.Password -AsPlainText -Force)
                Add-LocalGroupMember -Group $_.Group -Member $_.Username
            }
        } else {
            $password = Read-Host -Prompt "Enter password" -AsSecureString
            New-LocalUser -Name $Username -Password $password
            if ($GroupName) {
                Add-LocalGroupMember -Group $GroupName -Member $Username
            }
        }
    }
    'Disable' {
        Disable-LocalUser -Name $Username
    }
    'Enable' {
        Enable-LocalUser -Name $Username
    }
    'Remove' {
        if ($Confirm) {
            Remove-LocalUser -Name $Username -Confirm
        }
    }
}`,
          description: 'Manages local users and group memberships'
        }
      };

      const template = templates[templateType];
      if (!template) {
        return res.status(400).json({ 
          error: 'Invalid template type',
          availableTemplates: Object.keys(templates)
        });
      }

      // Apply parameters if provided
      let customizedContent = template.content;
      if (parameters) {
        Object.entries(parameters).forEach(([key, value]) => {
          customizedContent = customizedContent.replace(new RegExp(`\\$${key}`, 'g'), value as string);
        });
      }

      res.json({
        ...template,
        content: customizedContent,
        customized: !!parameters,
        templateType
      });
    } catch (error) {
      logger.error('Error generating from template:', error);
      res.status(500).json({ error: 'Failed to generate from template' });
    }
  }

  // 13. PowerShell to other languages conversion
  async convertToLanguage(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const { targetLanguage } = req.body;
      
      const script = await Script.findByPk(scriptId);
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      if (!targetLanguage) {
        return res.status(400).json({ error: 'Target language is required' });
      }

      const conversions: Record<string, any> = {
        'python': {
          language: 'Python',
          extension: '.py',
          converted: `#!/usr/bin/env python3
# Converted from PowerShell: ${script.title}

import os
import sys
import subprocess

def main():
    # Example conversion
    path = sys.argv[1] if len(sys.argv) > 1 else "."
    
    # List files (equivalent to Get-ChildItem)
    for root, dirs, files in os.walk(path):
        for file in files:
            filepath = os.path.join(root, file)
            print(f"File: {filepath}")
    
    # Run command (equivalent to Invoke-Expression)
    result = subprocess.run(['ls', '-la'], capture_output=True, text=True)
    print(result.stdout)

if __name__ == "__main__":
    main()`,
          notes: [
            'PowerShell cmdlets converted to Python equivalents',
            'Parameter handling adapted to argparse pattern',
            'Error handling uses try-except blocks'
          ]
        },
        'bash': {
          language: 'Bash',
          extension: '.sh',
          converted: `#!/bin/bash
# Converted from PowerShell: ${script.title}

# Parse arguments
PATH_ARG="\${1:-.}"
FORCE=false

while getopts "f" opt; do
  case \$opt in
    f) FORCE=true ;;
  esac
done

# List files (equivalent to Get-ChildItem)
find "\$PATH_ARG" -type f -name "*" | while read -r file; do
    echo "Processing: \$file"
    # Add your logic here
done

# Error handling
if [ \$? -ne 0 ]; then
    echo "Error occurred" >&2
    exit 1
fi`,
          notes: [
            'PowerShell syntax converted to POSIX shell',
            'Uses standard Unix utilities',
            'Compatible with most Linux/Unix systems'
          ]
        },
        'javascript': {
          language: 'JavaScript (Node.js)',
          extension: '.js',
          converted: `#!/usr/bin/env node
// Converted from PowerShell: ${script.title}

const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

// Main function
async function main() {
    const targetPath = process.argv[2] || '.';
    
    // List files (equivalent to Get-ChildItem)
    function walkDir(dir) {
        const files = fs.readdirSync(dir);
        files.forEach(file => {
            const filepath = path.join(dir, file);
            const stat = fs.statSync(filepath);
            
            if (stat.isDirectory()) {
                walkDir(filepath);
            } else {
                console.log(\`File: \\\${filepath}\`);
            }
        });
    }
    
    walkDir(targetPath);
    
    // Execute command (equivalent to Invoke-Expression)
    exec('ls -la', (error, stdout, stderr) => {
        if (error) {
            console.error(\`Error: \\\${error.message}\`);
            return;
        }
        console.log(stdout);
    });
}

// Run the script
main().catch(console.error);`,
          notes: [
            'Async/await pattern for asynchronous operations',
            'Uses Node.js built-in modules',
            'Cross-platform compatible'
          ]
        }
      };

      const conversion = conversions[targetLanguage.toLowerCase()];
      if (!conversion) {
        return res.status(400).json({ 
          error: 'Unsupported target language',
          supportedLanguages: Object.keys(conversions)
        });
      }

      res.json({
        originalScript: {
          id: script.id,
          title: script.title,
          language: 'PowerShell'
        },
        ...conversion,
        conversionQuality: 0.75,
        warnings: [
          'Some PowerShell-specific features may not have direct equivalents',
          'Manual review and testing recommended',
          'Complex cmdlets may need custom implementation'
        ]
      });
    } catch (error) {
      logger.error('Error converting to language:', error);
      res.status(500).json({ error: 'Failed to convert script' });
    }
  }

  // 14. AI-powered script optimization
  async optimizeScript(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const { optimizationLevel = 'balanced' } = req.body;
      
      const script = await Script.findByPk(scriptId);
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const optimizations = {
        performance: [
          {
            type: 'pipeline-optimization',
            before: 'Get-ChildItem | Where-Object { $_.Length -gt 1000 } | ForEach-Object { $_.FullName }',
            after: 'Get-ChildItem | Where-Object Length -gt 1000 | Select-Object -ExpandProperty FullName',
            improvement: '30% faster execution'
          },
          {
            type: 'collection-optimization',
            before: '$array = @()\nforeach ($item in $items) { $array += $item }',
            after: '$array = [System.Collections.ArrayList]::new()\nforeach ($item in $items) { [void]$array.Add($item) }',
            improvement: 'O(n) instead of O(nÂ²) complexity'
          }
        ],
        memory: [
          {
            type: 'streaming-optimization',
            before: '$content = Get-Content -Path $file\n$content | ForEach-Object { Process-Line $_ }',
            after: 'Get-Content -Path $file -ReadCount 1000 | ForEach-Object { $_ | ForEach-Object { Process-Line $_ } }',
            improvement: 'Reduced memory usage for large files'
          }
        ],
        readability: [
          {
            type: 'variable-naming',
            before: '$x = Get-Process | Where-Object { $_.CPU -gt 50 }',
            after: '$highCpuProcesses = Get-Process | Where-Object { $_.CPU -gt 50 }',
            improvement: 'Clearer variable purpose'
          },
          {
            type: 'comment-addition',
            locations: [10, 25, 45],
            suggestion: 'Add explanatory comments for complex logic'
          }
        ]
      };

      const optimizationProfiles: Record<string, string[]> = {
        'performance': ['performance'],
        'memory': ['memory'],
        'readability': ['readability'],
        'balanced': ['performance', 'memory', 'readability'],
        'aggressive': ['performance', 'memory']
      };

      const selectedOptimizations = optimizationProfiles[optimizationLevel] || ['balanced'];
      const appliedOptimizations = selectedOptimizations.flatMap(opt => optimizations[opt as keyof typeof optimizations] || []);

      res.json({
        originalScript: {
          id: script.id,
          title: script.title
        },
        optimizationLevel,
        optimizations: appliedOptimizations,
        estimatedImprovement: {
          performance: '+25%',
          memory: '-30%',
          readability: '+40%'
        },
        optimizedScript: '# Optimized version with improvements applied\n' + script.content
      });
    } catch (error) {
      logger.error('Error optimizing script:', error);
      res.status(500).json({ error: 'Failed to optimize script' });
    }
  }

  // 15. Dependency analysis
  async analyzeDependencies(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Analyze script content for dependencies
      const content = script.content.toLowerCase();
      const dependencies = {
        modules: [],
        cmdlets: [],
        externalCommands: [],
        psVersion: '5.1',
        dotNetVersion: '4.7.2'
      };

      // Check for module imports
      if (content.includes('import-module')) {
        dependencies.modules.push(
          { name: 'ActiveDirectory', version: '1.0', required: true },
          { name: 'AzureRM', version: '6.13.1', required: false }
        );
      }

      // Check for specific cmdlets
      const cmdletPatterns = [
        'get-aduser', 'get-azurermvm', 'invoke-restmethod', 
        'invoke-webrequest', 'get-wmiobject', 'get-ciminstance'
      ];
      cmdletPatterns.forEach(cmdlet => {
        if (content.includes(cmdlet)) {
          dependencies.cmdlets.push({
            name: cmdlet,
            module: cmdlet.startsWith('get-ad') ? 'ActiveDirectory' : 'Core',
            availability: 'Windows PowerShell 5.1+'
          });
        }
      });

      // Check for external commands
      if (content.includes('robocopy') || content.includes('xcopy')) {
        dependencies.externalCommands.push({
          command: 'robocopy',
          type: 'Windows Command',
          alternatives: ['Copy-Item with -Recurse']
        });
      }

      // Compatibility analysis
      const compatibility = {
        windowsPowerShell: true,
        powerShellCore: content.includes('get-wmiobject') ? false : true,
        crossPlatform: !content.includes('get-wmiobject') && !content.includes('registry'),
        minimumPSVersion: dependencies.psVersion,
        warnings: []
      };

      if (content.includes('get-wmiobject')) {
        compatibility.warnings.push('Get-WmiObject is deprecated, use Get-CimInstance for PowerShell 7+ compatibility');
      }

      res.json({
        scriptId,
        dependencies,
        compatibility,
        missingDependencies: [
          { type: 'module', name: 'Required module not installed', severity: 'high' }
        ],
        installCommands: [
          'Install-Module -Name ActiveDirectory -Force',
          'Install-Module -Name AzureRM -Force -AllowClobber'
        ]
      });
    } catch (error) {
      logger.error('Error analyzing dependencies:', error);
      res.status(500).json({ error: 'Failed to analyze dependencies' });
    }
  }

  // 16. Generate PowerShell module from scripts
  async generateModule(req: Request, res: Response) {
    try {
      const { scriptIds, moduleName, moduleVersion = '1.0.0' } = req.body;
      
      if (!scriptIds || !Array.isArray(scriptIds) || !moduleName) {
        return res.status(400).json({ error: 'Script IDs and module name are required' });
      }

      // Fetch all scripts
      const scripts = await Promise.all(
        scriptIds.map(id => Script.findByPk(id))
      );

      if (scripts.some(s => !s)) {
        return res.status(404).json({ error: 'One or more scripts not found' });
      }

      // Generate module structure
      const moduleManifest = `@{
    ModuleVersion = '${moduleVersion}'
    GUID = '${generateGUID()}'
    Author = 'PSScript AI Generator'
    CompanyName = 'PSScript Manager'
    Copyright = '(c) ${new Date().getFullYear()} PSScript Manager. All rights reserved.'
    Description = 'Auto-generated PowerShell module containing ${scripts.length} functions'
    PowerShellVersion = '5.1'
    
    # Functions to export
    FunctionsToExport = @(${scripts.map(s => `'${s!.title.replace(/\s+/g, '-')}'`).join(', ')})
    
    # Cmdlets to export
    CmdletsToExport = @()
    
    # Variables to export
    VariablesToExport = '*'
    
    # Aliases to export
    AliasesToExport = @()
}`;

      const moduleScript = `# ${moduleName} PowerShell Module
# Auto-generated by PSScript AI

${scripts.map(s => `
function ${s!.title.replace(/\s+/g, '-')} {
    <#
    .SYNOPSIS
        ${s!.description || s!.title}
    
    .DESCRIPTION
        Auto-generated function from script: ${s!.title}
    #>
    
${s!.content}
}`).join('\n\n')}

# Export module members
Export-ModuleMember -Function ${scripts.map(s => `'${s!.title.replace(/\s+/g, '-')}'`).join(', ')}`;

      const moduleStructure = {
        name: moduleName,
        version: moduleVersion,
        files: [
          {
            path: `${moduleName}\\\\${moduleName}.psd1`,
            content: moduleManifest,
            type: 'manifest'
          },
          {
            path: `${moduleName}\\\\${moduleName}.psm1`,
            content: moduleScript,
            type: 'script'
          },
          {
            path: `${moduleName}\\\\README.md`,
            content: `# ${moduleName}\n\nAuto-generated PowerShell module containing ${scripts.length} functions.\n\n## Installation\n\n\`\`\`powershell\nImport-Module .\\\\${moduleName}\n\`\`\`\n\n## Functions\n\n${scripts.map(s => `- **${s!.title.replace(/\s+/g, '-')}**: ${s!.description || 'No description'}\n`).join('')}`,
            type: 'documentation'
          }
        ],
        installCommand: `Import-Module .\\\\${moduleName}\\\\${moduleName}.psd1`,
        publishCommand: `Publish-Module -Path .\\\\${moduleName} -Repository PSGallery -NuGetApiKey \$apiKey`
      };

      res.json(moduleStructure);
    } catch (error) {
      logger.error('Error generating module:', error);
      res.status(500).json({ error: 'Failed to generate module' });
    }
  }

  // 17. AI chat assistant for PowerShell help
  async chatAssistant(req: Request, res: Response) {
    try {
      const { message, context, sessionId } = req.body;
      
      if (!message) {
        return res.status(400).json({ error: 'Message is required' });
      }

      const mode = getAIMode();
      let response: any;

      if (mode === 'real') {
        // Real AI chat implementation
        response = {
          reply: 'AI assistant response would appear here',
          suggestions: []
        };
      } else {
        // Mock implementation with context-aware responses
        const responses: Record<string, any> = {
          'error': {
            reply: 'I can help you troubleshoot that error. Based on the error message, it seems like a permission issue. Try running PowerShell as Administrator or check the file permissions.',
            suggestions: [
              'Run as Administrator',
              'Check file permissions with Get-Acl',
              'Use -Force parameter if applicable'
            ],
            relatedCommands: ['Get-Acl', 'Set-ExecutionPolicy', 'Unblock-File']
          },
          'performance': {
            reply: 'To improve PowerShell script performance, consider using .NET methods instead of cmdlets for large operations, utilize the pipeline efficiently, and avoid using += with arrays.',
            suggestions: [
              'Use [System.Collections.ArrayList] for dynamic arrays',
              'Replace Where-Object with .Where() method for large collections',
              'Use -ReadCount parameter with Get-Content for large files'
            ],
            relatedCommands: ['Measure-Command', 'Get-Counter', 'Trace-Command']
          },
          'default': {
            reply: 'I\'m here to help with PowerShell questions. You can ask about cmdlets, scripting best practices, error troubleshooting, or performance optimization.',
            suggestions: [
              'How do I handle errors in PowerShell?',
              'What\'s the best way to work with CSV files?',
              'How can I make my scripts more secure?'
            ],
            relatedCommands: ['Get-Help', 'Get-Command', 'Get-Member']
          }
        };

        // Simple keyword matching
        let selectedResponse = responses.default;
        if (message.toLowerCase().includes('error') || message.toLowerCase().includes('fail')) {
          selectedResponse = responses.error;
        } else if (message.toLowerCase().includes('performance') || message.toLowerCase().includes('slow')) {
          selectedResponse = responses.performance;
        }

        response = {
          ...selectedResponse,
          sessionId: sessionId || 'mock-session-' + Date.now(),
          context: context || 'general',
          timestamp: new Date().toISOString()
        };
      }

      res.json(response);
    } catch (error) {
      logger.error('Error in chat assistant:', error);
      res.status(500).json({ error: 'Failed to process chat message' });
    }
  }

  // 18. Script execution prediction
  async predictExecution(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const { parameters } = req.body;
      
      const script = await Script.findByPk(scriptId);
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Analyze script for potential execution outcomes
      const content = script.content.toLowerCase();
      
      const prediction = {
        willModifyFiles: content.includes('set-content') || content.includes('out-file') || content.includes('remove-item'),
        willModifyRegistry: content.includes('set-itemproperty') && content.includes('registry:'),
        willNetworkAccess: content.includes('invoke-webrequest') || content.includes('invoke-restmethod'),
        willCreateProcesses: content.includes('start-process') || content.includes('start-job'),
        requiresElevation: content.includes('#requires -runasadministrator') || content.includes('admin'),
        
        estimatedChanges: [
          {
            type: 'file',
            action: 'create',
            path: 'C:\\Logs\\script-output.log',
            reversible: true
          },
          {
            type: 'registry',
            action: 'modify',
            path: 'HKLM:\\SOFTWARE\\MyApp',
            reversible: true
          }
        ],
        
        potentialRisks: [
          {
            risk: 'File deletion',
            severity: 'high',
            mitigation: 'Use -WhatIf parameter first'
          },
          {
            risk: 'Network dependency',
            severity: 'medium',
            mitigation: 'Ensure network connectivity'
          }
        ],
        
        resourceUsage: {
          cpu: 'low',
          memory: 'medium',
          disk: 'high',
          network: content.includes('invoke-webrequest') ? 'yes' : 'no'
        },
        
        executionPlan: [
          'Validate input parameters',
          'Check prerequisites',
          'Execute main logic',
          'Log results',
          'Clean up temporary files'
        ]
      };

      res.json(prediction);
    } catch (error) {
      logger.error('Error predicting execution:', error);
      res.status(500).json({ error: 'Failed to predict execution' });
    }
  }

  // 19. Code smell detection
  async detectCodeSmells(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const script = await Script.findByPk(scriptId);
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      const codeSmells = [
        {
          type: 'long-function',
          severity: 'medium',
          location: { start: 50, end: 200 },
          description: 'Function exceeds 150 lines',
          suggestion: 'Consider breaking into smaller functions',
          refactoringType: 'extract-function'
        },
        {
          type: 'duplicate-code',
          severity: 'high',
          locations: [{ start: 25, end: 35 }, { start: 125, end: 135 }],
          description: 'Similar code blocks detected',
          suggestion: 'Extract common logic into a helper function',
          refactoringType: 'extract-method'
        },
        {
          type: 'magic-numbers',
          severity: 'low',
          locations: [15, 67, 89],
          description: 'Hard-coded numeric values without explanation',
          suggestion: 'Define constants with meaningful names',
          examples: [
            { line: 15, value: '86400', suggestion: '$SECONDS_PER_DAY = 86400' }
          ]
        },
        {
          type: 'unused-variables',
          severity: 'low',
          variables: ['$tempData', '$oldPath'],
          description: 'Variables declared but never used',
          suggestion: 'Remove unused variables'
        },
        {
          type: 'inconsistent-naming',
          severity: 'medium',
          examples: ['$userName', '$user_count', '$USERPATH'],
          description: 'Inconsistent variable naming conventions',
          suggestion: 'Use consistent PascalCase or camelCase'
        },
        {
          type: 'missing-error-handling',
          severity: 'high',
          locations: [45, 78, 92],
          description: 'Operations that could fail without try-catch',
          suggestion: 'Add proper error handling'
        }
      ];

      const metrics = {
        totalSmells: codeSmells.length,
        bySeverity: {
          high: codeSmells.filter(s => s.severity === 'high').length,
          medium: codeSmells.filter(s => s.severity === 'medium').length,
          low: codeSmells.filter(s => s.severity === 'low').length
        },
        codeQualityScore: Math.max(0, 100 - (codeSmells.length * 5)),
        refactoringPriority: codeSmells
          .filter(s => s.severity === 'high')
          .map(s => s.type)
      };

      res.json({
        scriptId,
        codeSmells,
        metrics,
        recommendations: [
          'Address high-severity issues first',
          'Consider using a linter like PSScriptAnalyzer',
          'Implement code review process'
        ]
      });
    } catch (error) {
      logger.error('Error detecting code smells:', error);
      res.status(500).json({ error: 'Failed to detect code smells' });
    }
  }

  // 20. Generate script changelog
  async generateChangelog(req: Request, res: Response) {
    try {
      const scriptId = parseInt(req.params.id);
      const { fromVersion, toVersion } = req.query;
      
      const script = await Script.findByPk(scriptId, {
        include: ['versions']
      });
      
      if (!script) {
        return res.status(404).json({ error: 'Script not found' });
      }

      // Generate AI-powered changelog
      const changelog = {
        scriptId,
        scriptTitle: script.title,
        fromVersion: fromVersion || '1.0.0',
        toVersion: toVersion || script.version,
        generatedAt: new Date().toISOString(),
        summary: 'Multiple improvements and bug fixes across various functions',
        
        changes: [
          {
            version: '1.2.0',
            date: '2024-03-15',
            type: 'feature',
            description: 'Added support for parallel processing',
            details: [
              'Implemented ForEach-Object -Parallel for better performance',
              'Added -ThrottleLimit parameter',
              'Backwards compatible with PowerShell 5.1'
            ],
            breakingChanges: false
          },
          {
            version: '1.1.5',
            date: '2024-03-10',
            type: 'bugfix',
            description: 'Fixed error handling in file operations',
            details: [
              'Resolved issue with paths containing spaces',
              'Improved error messages for better debugging',
              'Added validation for input parameters'
            ],
            breakingChanges: false
          },
          {
            version: '1.1.0',
            date: '2024-03-01',
            type: 'enhancement',
            description: 'Performance optimizations',
            details: [
              'Replaced array concatenation with ArrayList',
              'Optimized regex patterns',
              'Reduced memory usage by 40%'
            ],
            breakingChanges: false
          },
          {
            version: '1.0.5',
            date: '2024-02-20',
            type: 'security',
            description: 'Security improvements',
            details: [
              'Removed hard-coded credentials',
              'Added SecureString parameter support',
              'Implemented proper secret handling'
            ],
            breakingChanges: true,
            migration: 'Update credential parameters to use SecureString type'
          }
        ],
        
        statistics: {
          totalChanges: 4,
          features: 1,
          bugfixes: 1,
          enhancements: 1,
          security: 1,
          breakingChanges: 1
        },
        
        contributors: [
          { name: 'AI Assistant', commits: 10 },
          { name: script.user?.username || 'Unknown', commits: 5 }
        ],
        
        recommendations: [
          'Review breaking changes before upgrading',
          'Test thoroughly in non-production environment',
          'Update documentation to reflect new features'
        ]
      };

      res.json(changelog);
    } catch (error) {
      logger.error('Error generating changelog:', error);
      res.status(500).json({ error: 'Failed to generate changelog' });
    }
  }
}

// Helper function to generate GUID
function generateGUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

export default new AIController();